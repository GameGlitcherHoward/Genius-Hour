<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash: Glitch Apocalypse</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #000000, #333333);
      color: white;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Game variables
    const player = {
      x: 50,
      y: canvas.height - 150,
      width: 30,
      height: 30,
      color: "cyan",
      velocityY: 0,
      jumpStrength: 15,
      gravity: 0.8,
      onGround: true,
    };

    const platforms = [];
    const spikes = [];
    let scrollSpeed = 5;
    let score = 0;
    let isRunning = true;

    // Key handling
    let keys = {};
    window.addEventListener("keydown", (e) => (keys[e.key] = true));
    window.addEventListener("keyup", (e) => (keys[e.key] = false));

    function createPlatform() {
      const width = Math.random() * 200 + 100;
      const height = 20;
      platforms.push({
        x: canvas.width,
        y: Math.random() * (canvas.height - 200) + 100,
        width: width,
        height: height,
        color: "green",
      });
    }

    function createSpike(platform) {
      spikes.push({
        x: platform.x + Math.random() * (platform.width - 20),
        y: platform.y - 20,
        width: 20,
        height: 20,
        color: "red",
      });
    }

    function update() {
      // Player gravity and movement
      player.velocityY += player.gravity;
      player.y += player.velocityY;

      if (keys[" "] && player.onGround) {
        player.velocityY = -player.jumpStrength;
        player.onGround = false;
      }

      // Platform and spike logic
      platforms.forEach((platform, index) => {
        platform.x -= scrollSpeed;

        // Player collision with platforms
        if (
          player.x + player.width > platform.x &&
          player.x < platform.x + platform.width &&
          player.y + player.height <= platform.y &&
          player.y + player.height + player.velocityY >= platform.y
        ) {
          player.y = platform.y - player.height;
          player.velocityY = 0;
          player.onGround = true;
        }

        // Remove off-screen platforms
        if (platform.x + platform.width < 0) {
          platforms.splice(index, 1);
        }
      });

      spikes.forEach((spike, index) => {
        spike.x -= scrollSpeed;

        // Check for collision with spikes
        if (
          player.x < spike.x + spike.width &&
          player.x + player.width > spike.x &&
          player.y < spike.y + spike.height &&
          player.y + player.height > spike.y
        ) {
          isRunning = false;
        }

        // Remove off-screen spikes
        if (spike.x + spike.width < 0) {
          spikes.splice(index, 1);
        }
      });

      // Create new platforms and spikes
      if (platforms.length < 5 || platforms[platforms.length - 1].x < canvas.width - 300) {
        const newPlatform = {
          x: canvas.width,
          y: Math.random() * (canvas.height - 200) + 100,
          width: Math.random() * 200 + 100,
          height: 20,
          color: "green",
        };
        platforms.push(newPlatform);
        if (Math.random() > 0.5) {
          createSpike(newPlatform);
        }
      }

      // Check if the player falls off screen
      if (player.y > canvas.height) {
        isRunning = false;
      }

      // Increment score
      score++;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Draw platforms
      platforms.forEach((platform) => {
        ctx.fillStyle = platform.color;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
      });

      // Draw spikes
      spikes.forEach((spike) => {
        ctx.fillStyle = spike.color;
        ctx.beginPath();
        ctx.moveTo(spike.x, spike.y + spike.height);
        ctx.lineTo(spike.x + spike.width / 2, spike.y);
        ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
        ctx.closePath();
        ctx.fill();
      });

      // Draw score
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText(`Score: ${score}`, 10, 30);
    }

    function gameLoop() {
      if (isRunning) {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      } else {
        ctx.fillStyle = "red";
        ctx.font = "50px Arial";
        ctx.fillText("Game Over", canvas.width / 2 - 150, canvas.height / 2);
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2 - 150, canvas.height / 2 + 60);
      }
    }

    // Initialize game
    platforms.push({
      x: 0,
      y: canvas.height - 100,
      width: canvas.width,
      height: 20,
      color: "green",
    });
    gameLoop();
  </script>
</body>
</html>
